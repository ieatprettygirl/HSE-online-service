# 1 Часть

## Диаграмма контейнеров
![alt text](pictures/Containers.png)

## Диаграмма компонентов (сервис откликов)
![alt text](pictures/Components.png)

API Gateway служит единой точкой входа для всех клиентских запросов (маршрутизатор). Контроллер откликов обрабатывает входящие HTTP-запросы, связанные с откликами пользователей на вакансии. Репозиторий откликов отвечает за взаимодействие с базой данных. Он выполняет операции CRUD для откликов пользователей.  Сторонний сервис уведомлений отвечает за отправку уведомлений компаниям об отклике на их вакансии.

# 2 Часть

## Диаграмма последовательностей сервиса откликов
![alt text](<pictures/Диаг. последовательности.png>)

Пользователь откликается на вакансию, тем самым передавая запрос к маршрутизатору. Он в свою очередь передаёт запрос контроллеру откликов, который его обрабатывает и обращаются к репозиторию откликов. Он отсылает запрос к БД, получает ответ от неё с необходимыми данными. Полученные данные (информацию для обработки запроса) передаёт обратно в контроллер. Контроллер откликов вызывает сторонний сервис уведомлений. Сервис отправляет подтверждение обратно в API Gateway, который возвращает ответ пользователю.

# 3 Часть

## Диаграмма классов UML (модель базы банных)
![alt text](<pictures/Диаг. классов.png>)

### Отношения между классами
- Один пользователь может подать несколько откликов на ваканси.   
- Одна вакансия может получать несколько откликов.  
- Одна компания может публиковать несколько вакансий.  
- Один пользователь может давать несколько откликов.  
- Одна компания может давать несколько откликов.  
- Одна роль может быть у нескольких пользователей.  

У некоторых сущностей есть методы классов (к примеру: "void createJob()" у "Company", который предназначен для создания новой вакансии).

# 4 Часть

**Принцип KISS:** метод "register" в классе "User" (пользователи) выполняет одну единственную задачу и отвечает за регистрацию юзера.  
**Принцип YAGNI:** в классе "User"  метод "login" реализует только необходимую логику для проверки существования пользователя и пароля, избегая излишних действий и сложности.

![alt text](fragments/userLogAndReg.png)

**Принцип DRY:** у нас есть несколько классов, которые требуют валидации email (при регистрации пользователя и при изменении данных администратором), поэтому логика валидации вынесена в отдельную функцию.

![alt text](fragments/ValidateEmail.png)

**Принцип SOLID:**

Класс User Repository отвечает только за операции с базой данных, связанные с пользователями.

![alt text](fragments/userRepClass.png)

**Сделал для примера (не используется, поскольку подобного функционала не будет, тажке нет необходимости в наследовании)**:  создание подклассов для "Job": "RemoteJob", который не изменяет основной класс "Job".

![alt text](fragments/JobLogic.png)

Принцип разделения интерфейсов: юзеры не должны зависеть от интерфейсов, которые они не используют.
Пример: отдельные интерфейсы для различных типов уведомлений, чтобы пользователи могли реализовывать только те методы, которые им нужны.

![alt text](fragments/Notifier.png)

Класс, который управляет вакансиями не зависет от конкретных реализаций модулей-классов, которые обрабатывают публикацию вакансий или отправляют уведомления.

![alt text](fragments/RealizeInt.png)

![alt text](fragments/Jobs.png)